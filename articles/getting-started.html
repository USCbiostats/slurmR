<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Getting Started with slurmR • slurmR</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Getting Started with slurmR">
<meta property="og:description" content="slurmR">
<meta property="og:image" content="/logo.svg">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-108627422-2"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-108627422-2');
</script>
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">slurmR</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.5-3</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/debugging-re-submission.html">Re-submission and debugging</a>
    </li>
    <li>
      <a href="../articles/getting-started.html">Getting Started with slurmR</a>
    </li>
    <li>
      <a href="../articles/working-with-slurm.html">Working with Slurm</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/USCbiostats/slurmR/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Getting Started with slurmR</h1>
                        <h4 data-toc-skip class="author">George G. Vega
Yon</h4>
            
            <h4 data-toc-skip class="date">June 26, 2019 (last update
Feb 4, 2020)</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/USCbiostats/slurmR/blob/HEAD/vignettes/getting-started.Rmd" class="external-link"><code>vignettes/getting-started.Rmd</code></a></small>
      <div class="hidden name"><code>getting-started.Rmd</code></div>

    </div>

    
    
<div class="section level2">
<h2 id="the-slurmr-r-package">The slurmR R package<a class="anchor" aria-label="anchor" href="#the-slurmr-r-package"></a>
</h2>
<p>The <code>slurmR</code> package provides wrappers and tools for
integrating R with the HPC workload manager <a href="https://slurm.schedmd.com/" class="external-link">Slurm</a>. Overall, there are two
different approaches to do so, either using Socket clusters, in essence,
following the workflow of CRAN’s <code>parallel</code> package, or using
Job arrays, which are a different implementation of the same idea behind
the <code>par*apply</code> functions in the <code>parallel</code>
package, which, at times, can be more powerful.</p>
<div class="section level3">
<h3 id="socket-clusters">Socket clusters<a class="anchor" aria-label="anchor" href="#socket-clusters"></a>
</h3>
<p>Another important component of <code>slurmR</code> is
<code>makeSlurmCluster</code> function. This allow users creating
multi-node PSOCKCluster class objects. The implementation of this
function, wrapper of <code><a href="https://rdrr.io/r/parallel/makeCluster.html" class="external-link">parallel::makePSOCKcluster</a></code>, is very
simple:</p>
<ol style="list-style-type: decimal">
<li><p>It submits a job to Slurm requesting the desired number of tasks.
Each task will then return information regarding the node at which it is
operating.</p></li>
<li><p>Once Slurm allocates the resources, the master R session (from
which the job was submitted) will read in the node names returned by
each task.</p></li>
<li><p>With the full list of nodenames in usage,
<code>makeSlurmCluster</code> will pass the list of names to
<code><a href="https://rdrr.io/r/parallel/makeCluster.html" class="external-link">parallel::makePSOCKcluster</a></code>, which ultimately creates the
<code>cluster</code> class object.</p></li>
</ol>
<p>After creating the cluster object, the workflow is exactly the same
as with the <code>parallel</code> package. Here is an example from the
<code>makeSlurmCluster</code> manual</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Creating a cluster with 100 workers/offpring/child R sessions</span></span>
<span><span class="va">cl</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/makeSlurmCluster.html">makeSlurmCluster</a></span><span class="op">(</span><span class="fl">100</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Computing the mean of a 100 random uniforms within each worker</span></span>
<span><span class="co"># for this we can use any of the function available in the parallel package.</span></span>
<span><span class="va">ans</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/parallel/clusterApply.html" class="external-link">parSapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">200</span>, <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">100</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># We simply call stopCluster as we would do with any other cluster</span></span>
<span><span class="co"># object</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/parallel/makeCluster.html" class="external-link">stopCluster</a></span><span class="op">(</span><span class="va">ans</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="job-arrays-using-the-apply-family">Job arrays using the *apply family<a class="anchor" aria-label="anchor" href="#job-arrays-using-the-apply-family"></a>
</h3>
<p>Whenever <code>Slurm_lapply</code>, <code>Slurm_sapply</code>, or
<code>Slurm_Map</code> are called, a lot of things happen under the
hood. What the user does not see is the way in which <code>slurmR</code>
sets us a job and submits it to the queue.</p>
<p>Just like <code>rslurm</code>, <code>slurmR</code> has two levels of
job distribution: first, Slurm Jobs, and second, within each job via
<code><a href="https://rdrr.io/r/parallel/mclapply.html" class="external-link">parallel::mclapply</a></code> and <code><a href="https://rdrr.io/r/parallel/mclapply.html" class="external-link">parallel::mcMap</a></code> (task
forking). In general, the function <code>Slurm_*</code> is implemented
as follows:</p>
<ol style="list-style-type: decimal">
<li><p>List whatever R packages are loaded, including the path to the R
package.</p></li>
<li><p>List all the objects passed via ellipsis (<code>...</code>), and,
together with <code>X</code> and <code>FUN</code> or <code>f</code>,
save them at <code>[tmp_path]/[job_name]/</code> as
<code>[object-name].rds</code>.</p></li>
<li><p>Write out the corresponding R script and Slurm bash file, and
save them as <code>[tmp_path]/[job_name]/00-rscript.r</code>, and
<code>[tmp_path]/[job_name]/01-bash.sh</code> respectively.</p></li>
<li><p>If <code>plan = "collect"</code> (the default), the job will be
submitted to the queue via <code><a href="../reference/sbatch.html">sbatch()</a></code>, and the function will
wait until is flagged as completed by Slurm.</p></li>
<li><p>Once <code><a href="../reference/sbatch.html">sbatch()</a></code> is called, a Job Array will be
submitted in which each R job will lunch up to <code>mc.cores</code>
forked processes (second layer of palatalization)</p></li>
</ol>
<p>Once it is done, the the results can be collected using
<code>Slurm_collect</code>, which happens automatically if the user set
<code>plan = "collect"</code>.</p>
<p>The next section discusses some advantages of submitting jobs using
socket clusters versus job arrays.</p>
</div>
<div class="section level3">
<h3 id="sockets-vs-arrays">Sockets vs Arrays<a class="anchor" aria-label="anchor" href="#sockets-vs-arrays"></a>
</h3>
<p>While socket clusters, created via <code>makePSOCKcluster</code> or,
in the case of slurmR, via <code>makeSlurmCluster</code>, may be more
efficient in terms of data communication<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>, using job arrays has
some important benefits over socket cluster:</p>
<ol style="list-style-type: decimal">
<li><p>The number of workers can be much higher than clusters with the
parallel package.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> Users needing to work with hundreds or
thousands of jobs/instances may need to use job arrays instead.</p></li>
<li><p>If part of the job fails due to a failure of one of the tasks in
the array, the job can be easily resubmitted. The same is not
necessarily true for socket clusters.</p></li>
<li><p>Job arrays can run independently from the main session that
started the job. This means that, if for some reason the main session
crashes or stops, the job arrays will continue working regardless, and
what’s more, the results can be collected anyway.</p></li>
</ol>
</div>
</div>
<div class="section level2">
<h2 id="example-simulating-pi">Example simulating Pi<a class="anchor" aria-label="anchor" href="#example-simulating-pi"></a>
</h2>
<p>We would like to implement a simulation algorithm to be run in a
cluster. In this case, we have the very simple function we would like to
parallelize:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">simpi</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">n</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">points</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">n</span><span class="op">*</span><span class="fl">2</span><span class="op">)</span>, ncol<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">rowSums</a></span><span class="op">(</span><span class="va">points</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span> <span class="op">&lt;=</span> <span class="fl">1</span><span class="op">)</span><span class="op">*</span><span class="fl">4</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>This simple function generates an estimate of Pi. This approximation
is based on the following observation</p>
<p><span class="math display">\[
\mbox{Area} = \pi\times r^2 \implies \frac{Area}{r^2} = \pi
\]</span></p>
<p>Since we know what <span class="math inline">\(r\)</span> is, we just
need to get an estimate of the Area to obtain an approximation of <span class="math inline">\(\pi\)</span>. A rather simple way of doing so is
with Monte Carlo simulations, in particular, sampling points in a unit
square. The proportion of points that fall within the unit circle,
i.e. the proportion of points whose distance to the origin is smaller
than the radius of the circle, has an expected value equal to the area
of its circumscribed circle (for more details, check out the Wikipedia
article about this topic <a href="https://en.wikipedia.org/wiki/Approximations_of_%CF%80#Summing_a_circle's_area" class="external-link">here</a>).</p>
<div class="section level3">
<h3 id="single-node-machine-multi-core-simulation">Single node (machine), multi-core simulation<a class="anchor" aria-label="anchor" href="#single-node-machine-multi-core-simulation"></a>
</h3>
<p>Using <code><a href="https://rdrr.io/r/parallel/mclapply.html" class="external-link">parallel::mclapply</a></code>, we could just type</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">12</span><span class="op">)</span></span>
<span><span class="va">ans</span> <span class="op">&lt;-</span> <span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/mclapply.html" class="external-link">mclapply</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1e6</span>, <span class="fl">100</span><span class="op">)</span>, <span class="va">simpi</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/unlist.html" class="external-link">unlist</a></span><span class="op">(</span><span class="va">ans</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Which estimates pi using a single node(computer).</p>
</div>
<div class="section level3">
<h3 id="multi-job-submission-with-job-arrays">Multi-job submission with job arrays<a class="anchor" aria-label="anchor" href="#multi-job-submission-with-job-arrays"></a>
</h3>
<p>In the case of job arrays, we can use the <code>Slurm_lapply</code>
function implemented in the package. Before submitting a job to the
queue, we need to specify some options that are needed to create it:</p>
<ul>
<li><p><code>tmp_path</code>: A path to a directory to which all
computing nodes of the cluster have read+write access.</p></li>
<li><p><code>job_name</code>: The name of the job, passed to
<code>sbatch</code> via the <code>job-name</code> flag. This will also
be used as the name of the folder that is created within
<code>tmp_path</code>.</p></li>
</ul>
<p>Ultimately, all the objects saved by the job will be located in the
path defined by <code>tmp_path</code>/<code>job_name</code>.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/USCbiostats/slurmR" class="external-link">slurmR</a></span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Setting required parameters</span></span>
<span><span class="va">opts_slurmR</span><span class="op">$</span><span class="fu">set_tmp_path</span><span class="op">(</span><span class="st">"/stagging/slurmr-jobs/"</span><span class="op">)</span></span>
<span><span class="va">opts_slurmR</span><span class="op">$</span><span class="fu">set_job_name</span><span class="op">(</span><span class="st">"simulating-pi"</span><span class="op">)</span></span></code></pre></div>
<p>Moreover, we can specify more options to be set as default options
for all the jobs submitted for the current session. For example, we can
set the default partition and account as follows:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Optional parameters are set via set_opts</span></span>
<span><span class="va">opts_slurmR</span><span class="op">$</span><span class="fu">set_opts</span><span class="op">(</span>partition<span class="op">=</span><span class="st">"conti"</span>, account<span class="op">=</span><span class="st">"lc_dvc"</span><span class="op">)</span></span></code></pre></div>
<p>A comprehensive list of options can be found <a href="https://slurm.schedmd.com/sbatch.html" class="external-link">here</a>. To see what are
all the current defaults, we can just print the <code>opts_slurmR</code>
object:</p>
<pre><code><span><span class="va">opts_slurmR</span></span></code></pre>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Options for sbatch (Slurm workflow):</span></span>
<span><span class="co">##   partition   : conti</span></span>
<span><span class="co">##   account     : lc_dvc</span></span>
<span><span class="co">##   job-name    : simulating-pi</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Preamble:</span></span>
<span><span class="co">##   n/a</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Other options (R workflow):</span></span>
<span><span class="co">##   tmp_path    : /stagging/slurmr-jobs/</span></span>
<span><span class="co">##   cmd         : sbatch</span></span>
<span><span class="co">##   verbose     : FALSE</span></span>
<span><span class="co">##   debug       : FALSE</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## To get and set options for Slurm jobs creation use (see ?opts_slurmR):</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## debug_off : function ()  </span></span>
<span><span class="co">## debug_on : function ()  </span></span>
<span><span class="co">## get_cmd : function ()  </span></span>
<span><span class="co">## get_debug : function ()  </span></span>
<span><span class="co">## get_job_name : function (check = TRUE)  </span></span>
<span><span class="co">## get_opts_job : function (...)  </span></span>
<span><span class="co">## get_opts_r : function (...)  </span></span>
<span><span class="co">## get_preamble : function ()  </span></span>
<span><span class="co">## get_tmp_path : function ()  </span></span>
<span><span class="co">## get_verbose : function ()  </span></span>
<span><span class="co">## reset : function ()  </span></span>
<span><span class="co">## set_job_name : function (name)  </span></span>
<span><span class="co">## set_opts : function (...)  </span></span>
<span><span class="co">## set_preamble : function (...)  </span></span>
<span><span class="co">## set_tmp_path : function (path = Sys.getenv("SLURMR_TMP_PATH", getwd()))  </span></span>
<span><span class="co">## verbose_off : function ()  </span></span>
<span><span class="co">## verbose_on : function ()</span></span></code></pre>
<p>Once we have specified all the needed options, we can do our
<code>Slurm_lapply</code> call and submit the job to the queue as
follows:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">job</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Slurm_lapply.html">Slurm_lapply</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1e6</span>, <span class="fl">100</span><span class="op">)</span>, <span class="va">simpi</span>, njobs<span class="op">=</span><span class="fl">10</span>, mc.cores<span class="op">=</span><span class="fl">10</span>, plan <span class="op">=</span> <span class="st">"wait"</span><span class="op">)</span></span></code></pre></div>
<p>If <code>plan = "wait"</code>, then <code>Slurm_lapply</code> will
return once the job is done (or failed). To collect the results we can
use the <code>Slurm_collect</code> function:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ans</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Slurm_collect.html">Slurm_collect</a></span><span class="op">(</span><span class="va">job</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/unlist.html" class="external-link">unlist</a></span><span class="op">(</span><span class="va">ans</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Alternatively, we could have collected the results on the fly by
telling <code>slurmR</code> that the plan is to <code>"collect"</code>
the results:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ans</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Slurm_lapply.html">Slurm_lapply</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1e6</span>, <span class="fl">100</span><span class="op">)</span>, <span class="va">simpi</span>, njobs<span class="op">=</span><span class="fl">10</span>, mc.cores<span class="op">=</span><span class="fl">10</span>, plan <span class="op">=</span> <span class="st">"collect"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/unlist.html" class="external-link">unlist</a></span><span class="op">(</span><span class="va">job</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>This way <code>Slurm_lapply</code> will do the
<code>Slurm_collect</code> call before returning.</p>
</div>
<div class="section level3">
<h3 id="multi-node-cluster-object">Multi-node cluster object<a class="anchor" aria-label="anchor" href="#multi-node-cluster-object"></a>
</h3>
<p>Another way to do this is using <code><a href="https://rdrr.io/r/parallel/clusterApply.html" class="external-link">parallel::parLapply</a></code> with
a multi-node socket cluster.<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> To do this, we can use the
<code>makeSlurmCluster</code> function and proceed as follows:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cl</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/makeSlurmCluster.html">makeSlurmCluster</a></span><span class="op">(</span><span class="fl">50</span><span class="op">)</span></span>
<span><span class="va">ans</span> <span class="op">&lt;-</span> <span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/clusterApply.html" class="external-link">parLapply</a></span><span class="op">(</span><span class="va">cl</span>, <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1e6</span>, <span class="fl">100</span><span class="op">)</span>, <span class="va">simpi</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/unlist.html" class="external-link">unlist</a></span><span class="op">(</span><span class="va">ans</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Once we are done with the calculations, we can stop the cluster
object by simply calling the <code>stopCluster</code> function:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/parallel/makeCluster.html" class="external-link">stopCluster</a></span><span class="op">(</span><span class="va">cl</span><span class="op">)</span></span></code></pre></div>
<p>And <code>slurmR</code> will kill the job (and thus, the socket
connections) calling <code>scancel</code>.</p>
</div>
</div>
<div class="footnotes footnotes-end-of-document">
<hr>
<ol>
<li id="fn1"><p>Data transfering on Socket clusters is done using
serialization with the <code>serialize</code> and
<code>unserialize</code> functions. This way, data is sent directly
through the connection. In the case of job arrays, data is sent using
<code>saveRDS</code> and <code>readRDS</code> which involves I/O on the
disk.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>The current default configuration of R does not allow
having more than 128 connections simulatenously (see
<code><a href="https://rdrr.io/r/base/connections.html" class="external-link">?connection</a></code>). This can be changed during installation
time.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>In general, Slurm will try to allocate multiple tasks in
the same node (machine). But if no node with that many resources is
available, the tasks will span multiple nodes.<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by George Vega Yon, National Cancer Institute (NCI).</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
